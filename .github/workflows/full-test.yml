name: Full Interactive Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  run-interactive-tests:
    runs-on: ubuntu-latest
    
    steps:
      - name: 1. Checkout repository
        uses: actions/checkout@v4

      - name: 2. Grant Executable Permissions
        run: chmod +x ./script_fbs.sh

      - name: 3. Run Interactive Tests and Generate Report
        run: |
          # Define the report filename
          REPORT_FILE="test-options.txt"
          
          # Initialize the report file
          echo "--- Easy Ubuntu Script Test Report ---" > $REPORT_FILE
          echo "Date: $(date)" >> $REPORT_FILE
          echo "Commit: $GITHUB_SHA" >> $REPORT_FILE
          echo "" >> $REPORT_FILE

          # --- Helper Function ---
          # This function simplifies running each test
          # Usage: run_test "OptionNumber" "Test Name" "additional_input_1" "additional_input_2" ...
          run_test() {
            local option="$1"
            local test_name="$2"
            local expected=""
            shift 2 # Remove the first 2 arguments, the rest are inputs

            # If the caller provided an expected string, capture it from the end
            # Usage: run_test "1" "Show" "expected substring" "arg1" "arg2"
            if [ "$#" -gt 0 ]; then
              # Peek last arg: if caller passed more than two args and the last
              # looks like an expected string marker (we can't perfectly detect,
              # so callers should pass expected as the first of the remaining args
              # when needed). To keep the existing call sites unchanged, we will
              # treat an additional named parameter expected_text when provided
              # by explicit callers. For now, we don't automatically extract it.
              :
            fi

            echo "Testing: $test_name (Option $option)"

            # Build the input sequence. Append an extra blank line before the
            # final '30' to simulate pressing a key at the pause prompt.
            local input_sequence="$option\n"
            local args=("$@")
            for input in "${args[@]}"; do
              input_sequence+="$input\n"
            done
            input_sequence+="\n30\n"

            # Capture output to a temp file so we can assert on it
            out=$(mktemp)
            printf '%b' "$input_sequence" | sudo ./script_fbs.sh >"$out" 2>&1
            rc=$?

            # Append captured output (trim to first 300 lines) to the report for debugging
            echo "--- Output for $test_name (first 300 lines) ---" >> $REPORT_FILE
            sed -n '1,300p' "$out" >> $REPORT_FILE
            echo "--- End output ---" >> $REPORT_FILE

            if [ $rc -ne 0 ]; then
              echo "❌ $test_name: FAILED (exit $rc)" >> $REPORT_FILE
            else
              # If an expected substring is provided as the first extra arg, check it
              if [ ${#args[@]} -gt 0 ] && [ -n "${args[0]}" ]; then
                expected="${args[0]}"
              fi

              if [ -n "$expected" ]; then
                if grep -Fq "$expected" "$out"; then
                  echo "✅ $test_name: PASSED (found expected: $expected)" >> $REPORT_FILE
                else
                  echo "❌ $test_name: FAILED (expected not found: $expected)" >> $REPORT_FILE
                fi
              else
                # No expected string provided: success if exit code was 0
                echo "✅ $test_name: PASSED (exit 0)" >> $REPORT_FILE
              fi
            fi

            rm -f "$out"
          }

          # --- Test Execution ---
          # We test most of the non-interactive options
          
          run_test "1" "Show Linux Version" "PRETTY_NAME"
          # Skipping 2 (nano) and 3 (gedit) -> They are interactive editors
          run_test "4" "Install network tools (samba)"
          # Skipping 5 (Install groups) -> Option is empty
          run_test "6" "List files and directories" "tests"
          run_test "7" "Assign permissions (user)" "opciones incorrectas" "README.md" "1"
          run_test "8" "Show calendar" "Mostrando calendario"
          run_test "9" "Show friendly cow" "moore's law is dead"
          # Skipping 10 (man) and 11 (less) -> They are interactive viewers
          run_test "12" "Show specific file info (stat)" "File:"
          run_test "13" "Link files" "test_link" "README.md" "test_link"
          # Skipping 14 (Restart terminal) -> This would kill the CI runner and fail the job
          run_test "15" "Create folders" "my_test_folder" "my_test_folder"
          run_test "16" "Create files" "my_test_file.txt" "my_test_file.txt"
          # Skipping 17, 18, 22 (User/Group creation) -> They prompt for interactive passwords
          run_test "19" "Copy folders" "tests_copy" "tests" "tests_copy"
          run_test "20" "Delete folder" "my_test_folder" "my_test_folder"
          run_test "21" "Delete file" "my_test_file.txt" "my_test_file.txt"
          run_test "23" "List users" "root"
          run_test "24" "List groups" "sudo"
          run_test "25" "Update the system" "Reading package lists"
          run_test "26" "Create firewall rules (Allow)" "opened" "8080" "1"
          run_test "26" "Create firewall rules (Deny)" "closed" "9090" "2"
          run_test "27" "Enable firewall" "Firewall" 
          run_test "28" "Disable firewall" "Firewall"
          # Skipping 29 (SELF DESTRUCTION) -> It will shut down the PC and make the test end
          
          echo "" >> $REPORT_FILE
          echo "--- Test Report Complete ---"
          # Print the report to the GitHub Actions console for debugging
          cat $REPORT_FILE

      - name: 4. Upload Test Report Artifact
        # 'if: always()' ensures the report is uploaded even if the previous step fails
        if: always()
        uses: actions/upload-artifact@v4
        with:
          # The name of the file you'll see on the GitHub Actions summary page
          name: tests-options-report
          # The file that will be uploaded
          path: test-options.txt